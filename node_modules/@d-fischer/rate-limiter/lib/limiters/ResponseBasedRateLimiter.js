"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResponseBasedRateLimiter = void 0;
var tslib_1 = require("tslib");
var logger_1 = require("@d-fischer/logger");
var promise_allsettled_1 = require("@d-fischer/promise.allsettled");
var shared_utils_1 = require("@d-fischer/shared-utils");
var RateLimitReachedError_1 = require("../errors/RateLimitReachedError");
var RetryAfterError_1 = require("../errors/RetryAfterError");
var ResponseBasedRateLimiter = /** @class */ (function () {
    function ResponseBasedRateLimiter(_a) {
        var logger = _a.logger;
        this._queue = [];
        this._batchRunning = false;
        this._paused = false;
        this._logger = (0, logger_1.createLogger)(tslib_1.__assign({ name: 'rate-limiter', emoji: true }, logger));
    }
    ResponseBasedRateLimiter.prototype.request = function (req, options) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._logger.trace('request start');
                        return [4 /*yield*/, new Promise(function (resolve, reject) {
                                var _a;
                                var reqSpec = {
                                    req: req,
                                    resolve: resolve,
                                    reject: reject,
                                    limitReachedBehavior: (_a = options === null || options === void 0 ? void 0 : options.limitReachedBehavior) !== null && _a !== void 0 ? _a : 'enqueue'
                                };
                                if (_this._batchRunning || _this._nextBatchTimer || _this._paused) {
                                    _this._logger.trace("request queued batchRunning:".concat(_this._batchRunning.toString(), " hasNextBatchTimer:").concat((!!_this
                                        ._nextBatchTimer).toString(), " paused:").concat(_this._paused.toString()));
                                    _this._queue.push(reqSpec);
                                }
                                else {
                                    void _this._runRequestBatch([reqSpec]);
                                }
                            })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    ResponseBasedRateLimiter.prototype.clear = function () {
        this._queue = [];
    };
    ResponseBasedRateLimiter.prototype.pause = function () {
        this._paused = true;
    };
    ResponseBasedRateLimiter.prototype.resume = function () {
        this._paused = false;
        this._runNextBatch();
    };
    Object.defineProperty(ResponseBasedRateLimiter.prototype, "stats", {
        get: function () {
            var _a, _b, _c, _d, _e;
            return {
                lastKnownLimit: (_b = (_a = this._parameters) === null || _a === void 0 ? void 0 : _a.limit) !== null && _b !== void 0 ? _b : null,
                lastKnownRemainingRequests: (_d = (_c = this._parameters) === null || _c === void 0 ? void 0 : _c.remaining) !== null && _d !== void 0 ? _d : null,
                lastKnownResetDate: (0, shared_utils_1.mapNullable)((_e = this._parameters) === null || _e === void 0 ? void 0 : _e.resetsAt, function (v) { return new Date(v); })
            };
        },
        enumerable: false,
        configurable: true
    });
    ResponseBasedRateLimiter.prototype._runRequestBatch = function (reqSpecs) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var promises, settledPromises, rejectedPromises, now, retryAt, retryAfter, params, delay;
            var _this = this;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this._logger.trace("runRequestBatch start specs:".concat(reqSpecs.length));
                        this._batchRunning = true;
                        if (this._parameters) {
                            this._logger.debug("Remaining requests: ".concat(this._parameters.remaining));
                        }
                        this._logger.debug("Doing ".concat(reqSpecs.length, " requests, new queue length is ").concat(this._queue.length));
                        promises = reqSpecs.map(function (reqSpec) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                            var req, resolve, reject, result, retry, params, e_1;
                            return tslib_1.__generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        req = reqSpec.req, resolve = reqSpec.resolve, reject = reqSpec.reject;
                                        _a.label = 1;
                                    case 1:
                                        _a.trys.push([1, 3, , 4]);
                                        return [4 /*yield*/, this.doRequest(req)];
                                    case 2:
                                        result = _a.sent();
                                        retry = this.needsToRetryAfter(result);
                                        if (retry !== null) {
                                            this._queue.unshift(reqSpec);
                                            this._logger.info("Retrying after ".concat(retry, " ms"));
                                            throw new RetryAfterError_1.RetryAfterError(retry);
                                        }
                                        params = this.getParametersFromResponse(result);
                                        resolve(result);
                                        return [2 /*return*/, params];
                                    case 3:
                                        e_1 = _a.sent();
                                        if (e_1 instanceof RetryAfterError_1.RetryAfterError) {
                                            throw e_1;
                                        }
                                        reject(e_1);
                                        return [2 /*return*/, undefined];
                                    case 4: return [2 /*return*/];
                                }
                            });
                        }); });
                        return [4 /*yield*/, promise_allsettled_1.default.call(Promise, promises)];
                    case 1:
                        settledPromises = _a.sent();
                        rejectedPromises = settledPromises.filter(function (p) { return p.status === 'rejected'; });
                        now = Date.now();
                        if (rejectedPromises.length) {
                            this._logger.trace('runRequestBatch some rejected');
                            retryAt = Math.max.apply(Math, tslib_1.__spreadArray([now], tslib_1.__read(rejectedPromises.map(function (p) { return p.reason.retryAt; })), false));
                            retryAfter = retryAt - now;
                            this._logger.warn("Waiting for ".concat(retryAfter, " ms because the rate limit was exceeded"));
                            this._nextBatchTimer = setTimeout(function () {
                                _this._parameters = undefined;
                                _this._runNextBatch();
                            }, retryAfter);
                        }
                        else {
                            this._logger.trace('runRequestBatch none rejected');
                            params = settledPromises
                                .filter(function (p) {
                                return p.status === 'fulfilled' && p.value !== undefined;
                            })
                                .map(function (p) { return p.value; })
                                .reduce(function (carry, v) {
                                if (!carry) {
                                    return v;
                                }
                                // return v.resetsAt > carry.resetsAt ? v : carry;
                                return v.remaining < carry.remaining ? v : carry;
                            }, undefined);
                            this._batchRunning = false;
                            if (params) {
                                this._parameters = params;
                                if (params.resetsAt < now || params.remaining > 0) {
                                    this._logger.trace('runRequestBatch canRunMore');
                                    this._runNextBatch();
                                }
                                else {
                                    delay = params.resetsAt - now;
                                    this._logger.trace("runRequestBatch delay:".concat(delay));
                                    this._logger.warn("Waiting for ".concat(delay, " ms because the rate limit was reached"));
                                    this._queue = this._queue.filter(function (entry) {
                                        switch (entry.limitReachedBehavior) {
                                            case 'enqueue': {
                                                return true;
                                            }
                                            case 'null': {
                                                entry.resolve(null);
                                                return false;
                                            }
                                            case 'throw': {
                                                entry.reject(new RateLimitReachedError_1.RateLimitReachedError('Request removed from queue because the rate limit was reached'));
                                                return false;
                                            }
                                            default: {
                                                throw new Error('this should never happen');
                                            }
                                        }
                                    });
                                    this._nextBatchTimer = setTimeout(function () {
                                        _this._parameters = undefined;
                                        _this._runNextBatch();
                                    }, delay);
                                }
                            }
                        }
                        this._logger.trace('runRequestBatch end');
                        return [2 /*return*/];
                }
            });
        });
    };
    ResponseBasedRateLimiter.prototype._runNextBatch = function () {
        if (this._paused) {
            return;
        }
        this._logger.trace('runNextBatch start');
        if (this._nextBatchTimer) {
            clearTimeout(this._nextBatchTimer);
            this._nextBatchTimer = undefined;
        }
        var amount = this._parameters ? Math.min(this._parameters.remaining, this._parameters.limit / 10) : 1;
        var reqSpecs = this._queue.splice(0, amount);
        if (reqSpecs.length) {
            void this._runRequestBatch(reqSpecs);
        }
        this._logger.trace('runNextBatch end');
    };
    return ResponseBasedRateLimiter;
}());
exports.ResponseBasedRateLimiter = ResponseBasedRateLimiter;
