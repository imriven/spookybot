import { __assign, __awaiter, __generator, __values } from "tslib";
import { createLogger } from '@d-fischer/logger';
import { RateLimitReachedError } from "../errors/RateLimitReachedError.mjs";
var PartitionedTimeBasedRateLimiter = /** @class */ (function () {
    function PartitionedTimeBasedRateLimiter(_a) {
        var logger = _a.logger, bucketSize = _a.bucketSize, timeFrame = _a.timeFrame, doRequest = _a.doRequest, getPartitionKey = _a.getPartitionKey;
        this._partitionedQueue = new Map();
        this._usedFromBucket = new Map();
        this._paused = false;
        this._logger = createLogger(__assign({ name: 'rate-limiter', emoji: true }, logger));
        this._bucketSize = bucketSize;
        this._timeFrame = timeFrame;
        this._callback = doRequest;
        this._partitionKeyCallback = getPartitionKey;
    }
    PartitionedTimeBasedRateLimiter.prototype.request = function (req, options) {
        return __awaiter(this, void 0, Promise, function () {
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, new Promise(function (resolve, reject) {
                            var _a, _b;
                            var reqSpec = {
                                req: req,
                                resolve: resolve,
                                reject: reject,
                                limitReachedBehavior: (_a = options === null || options === void 0 ? void 0 : options.limitReachedBehavior) !== null && _a !== void 0 ? _a : 'enqueue'
                            };
                            var partitionKey = _this._partitionKeyCallback(req);
                            var usedFromBucket = (_b = _this._usedFromBucket.get(partitionKey)) !== null && _b !== void 0 ? _b : 0;
                            if (usedFromBucket >= _this._bucketSize || _this._paused) {
                                switch (reqSpec.limitReachedBehavior) {
                                    case 'enqueue': {
                                        var queue = _this._getPartitionedQueue(partitionKey);
                                        queue.push(reqSpec);
                                        if (usedFromBucket + queue.length >= _this._bucketSize) {
                                            _this._logger.warn("Rate limit of ".concat(_this._bucketSize, " for ").concat(partitionKey ? "partition ".concat(partitionKey) : 'default partition', " was reached, waiting for ").concat(_this._paused ? 'the limiter to be unpaused' : 'a free bucket entry', "; queue size is ").concat(queue.length));
                                        }
                                        else {
                                            _this._logger.info("Enqueueing request for ".concat(partitionKey ? "partition ".concat(partitionKey) : 'default partition', " because the rate limiter is paused; queue size is ").concat(queue.length));
                                        }
                                        break;
                                    }
                                    case 'null': {
                                        reqSpec.resolve(null);
                                        if (_this._paused) {
                                            _this._logger.info("Returning null for request for ".concat(partitionKey ? "partition ".concat(partitionKey) : 'default partition', " because the rate limiter is paused"));
                                        }
                                        else {
                                            _this._logger.warn("Rate limit of ".concat(_this._bucketSize, " for ").concat(partitionKey ? "partition ".concat(partitionKey) : 'default partition', " was reached, dropping request and returning null"));
                                        }
                                        break;
                                    }
                                    case 'throw': {
                                        reqSpec.reject(new RateLimitReachedError("Request dropped because ".concat(_this._paused
                                            ? 'the rate limiter is paused'
                                            : "the rate limit for ".concat(partitionKey ? "partition ".concat(partitionKey) : 'default partition', " was reached"))));
                                        break;
                                    }
                                    default: {
                                        throw new Error('this should never happen');
                                    }
                                }
                            }
                            else {
                                void _this._runRequest(reqSpec, partitionKey);
                            }
                        })];
                    case 1: return [2 /*return*/, _a.sent()];
                }
            });
        });
    };
    PartitionedTimeBasedRateLimiter.prototype.clear = function () {
        this._partitionedQueue.clear();
    };
    PartitionedTimeBasedRateLimiter.prototype.pause = function () {
        this._paused = true;
    };
    PartitionedTimeBasedRateLimiter.prototype.resume = function () {
        var e_1, _a;
        this._paused = false;
        try {
            for (var _b = __values(this._partitionedQueue.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var partitionKey = _c.value;
                this._runNextRequest(partitionKey);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    PartitionedTimeBasedRateLimiter.prototype._getPartitionedQueue = function (partitionKey) {
        if (this._partitionedQueue.has(partitionKey)) {
            return this._partitionedQueue.get(partitionKey);
        }
        var newQueue = [];
        this._partitionedQueue.set(partitionKey, newQueue);
        return newQueue;
    };
    PartitionedTimeBasedRateLimiter.prototype._runRequest = function (reqSpec, partitionKey) {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var queue, req, resolve, reject, _b, e_2;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        queue = this._getPartitionedQueue(partitionKey);
                        this._logger.debug("doing a request for ".concat(partitionKey ? "partition ".concat(partitionKey) : 'default partition', ", new queue length is ").concat(queue.length));
                        this._usedFromBucket.set(partitionKey, ((_a = this._usedFromBucket.get(partitionKey)) !== null && _a !== void 0 ? _a : 0) + 1);
                        req = reqSpec.req, resolve = reqSpec.resolve, reject = reqSpec.reject;
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 3, 4, 5]);
                        _b = resolve;
                        return [4 /*yield*/, this._callback(req)];
                    case 2:
                        _b.apply(void 0, [_c.sent()]);
                        return [3 /*break*/, 5];
                    case 3:
                        e_2 = _c.sent();
                        reject(e_2);
                        return [3 /*break*/, 5];
                    case 4:
                        setTimeout(function () {
                            var newUsed = _this._usedFromBucket.get(partitionKey) - 1;
                            _this._usedFromBucket.set(partitionKey, newUsed);
                            if (queue.length && newUsed < _this._bucketSize) {
                                _this._runNextRequest(partitionKey);
                            }
                        }, this._timeFrame);
                        return [7 /*endfinally*/];
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    PartitionedTimeBasedRateLimiter.prototype._runNextRequest = function (partitionKey) {
        if (this._paused) {
            return;
        }
        var queue = this._getPartitionedQueue(partitionKey);
        var reqSpec = queue.shift();
        if (reqSpec) {
            void this._runRequest(reqSpec, partitionKey);
        }
    };
    return PartitionedTimeBasedRateLimiter;
}());
export { PartitionedTimeBasedRateLimiter };
