import type { MakeOptional } from '@d-fischer/shared-utils';
import { type UserIdResolvable } from '@twurple/common';
import type { AccessToken, AccessTokenMaybeWithUserId, AccessTokenWithUserId } from '../AccessToken';
import { type AuthProvider } from './AuthProvider';
declare type OnRefreshCallbackWithUserId = (userId: string, token: AccessToken) => void;
declare type OnRefreshCallbackWithoutUserId = (token: AccessToken) => void;
declare type OnRefreshCallback = OnRefreshCallbackWithUserId | OnRefreshCallbackWithoutUserId;
/**
 * Configuration for the {@link RefreshingAuthProvider}.
 */
export interface RefreshConfig {
    /**
     * The client ID of your application.
     */
    clientId: string;
    /**
     * The client secret of your application.
     */
    clientSecret: string;
    /**
     * A callback that is called whenever the auth provider refreshes the token,
     * e.g. to save the new data in your database.
     *
     * @param userId The ID of the user.
     * @param token The token data.
     */
    onRefresh?: OnRefreshCallback;
    /**
     * A callback that is called whenever the auth provider fails to refresh the token,
     * e.g. to notify the user or remove them from your database.
     *
     * @param userId The ID of the user.
     */
    onRefreshFailure?: (userId: string) => void;
    /**
     * The scopes to be implied by the provider's app access token.
     */
    appImpliedScopes?: string[];
}
/**
 * An auth provider with the ability to make use of refresh tokens,
 * automatically refreshing the access token whenever necessary.
 */
export declare class RefreshingAuthProvider implements AuthProvider {
    private readonly _clientId;
    private readonly _clientSecret;
    private readonly _userAccessTokens;
    private readonly _userTokenFetchers;
    private readonly _intentToUserId;
    private readonly _userIdToIntents;
    private _appAccessToken?;
    private readonly _appTokenFetcher;
    private readonly _appImpliedScopes;
    private readonly _onRefresh?;
    private readonly _onRefreshFailure?;
    /**
     * Creates a new auth provider based on the given one that can automatically
     * refresh access tokens.
     *
     * @param refreshConfig The information necessary to automatically refresh an access token.
     */
    constructor(refreshConfig: RefreshConfig);
    /**
     * Adds the given user with their corresponding token to the provider.
     *
     * @param user The user to add.
     * @param initialToken The token for the user.
     * @param intents The intents to add to the user.
     *
     * Any intents that were already set before will be overwritten to point to this user instead.
     */
    addUser(user: UserIdResolvable, initialToken: MakeOptional<AccessToken, 'accessToken' | 'scope'>, intents?: string[]): void;
    /**
     * Figures out the user associated to the given token and adds them to the provider.
     *
     * If you already know the ID of the user you're adding,
     * consider using {@link RefreshingAuthProvider#addUser} instead.
     *
     * @param initialToken The token for the user.
     * @param intents The intents to add to the user.
     *
     * Any intents that were already set before will be overwritten to point to this user instead.
     */
    addUserForToken(initialToken: MakeOptional<AccessToken, 'accessToken' | 'scope'>, intents?: string[]): Promise<string>;
    /**
     * Checks whether a user was added to the provider.
     *
     * @param user The user to check.
     */
    hasUser(user: UserIdResolvable): boolean;
    /**
     * Removes a user from the provider.
     *
     * This also makes all intents this user was assigned to unusable.
     *
     * @param user The user to remove.
     */
    removeUser(user: UserIdResolvable): void;
    /**
     * Adds intents to a user.
     *
     * Any intents that were already set before will be overwritten to point to this user instead.
     *
     * @param user The user to add intents to.
     * @param intents The intents to add to the user.
     */
    addIntentsToUser(user: UserIdResolvable, intents: string[]): void;
    /**
     * Gets all intents assigned to the given user.
     *
     * @param user The user to get intents of.
     */
    getIntentsForUser(user: UserIdResolvable): string[];
    /**
     * Removes all given intents from any user who they might be assigned to.
     *
     * Intents that have not been assigned are silently ignored.
     *
     * @param intents The intents to remove.
     */
    removeIntents(intents: string[]): void;
    /**
     * Requests that the provider fetches a new token from Twitch for the given user.
     *
     * @param user The user to refresh the token for.
     */
    refreshAccessTokenForUser(user: UserIdResolvable): Promise<AccessTokenWithUserId>;
    /**
     * Requests that the provider fetches a new token from Twitch for the given intent.
     *
     * @param intent The intent to refresh the token for.
     */
    refreshAccessTokenForIntent(intent: string): Promise<AccessTokenWithUserId>;
    /**
     * The client ID.
     */
    get clientId(): string;
    /**
     * Gets the scopes that are currently available using the access token.
     *
     * @param user The user to get the current scopes for.
     */
    getCurrentScopesForUser(user: UserIdResolvable): string[];
    /**
     * Gets an access token for the given user.
     *
     * @param user The user to get an access token for.
     * @param scopes The requested scopes.
     */
    getAccessTokenForUser(user: UserIdResolvable, scopes?: string[]): Promise<AccessTokenWithUserId | null>;
    /**
     * Fetches a token for a user identified by the given intent.
     *
     * @param intent The intent to fetch a token for.
     * @param scopes The requested scopes.
     */
    getAccessTokenForIntent(intent: string, scopes?: string[]): Promise<AccessTokenWithUserId | null>;
    /**
     * Fetches any token to use with a request that supports both user and app tokens,
     * i.e. public data relating to a user.
     *
     * @param user The user.
     */
    getAnyAccessToken(user?: UserIdResolvable): Promise<AccessTokenMaybeWithUserId>;
    /**
     * Fetches an app access token.
     *
     * @param forceNew Whether to always get a new token, even if the old one is still deemed valid internally.
     */
    getAppAccessToken(forceNew?: boolean): Promise<AccessToken>;
    private _checkIntermediateUserRemoval;
    private _callOnRefresh;
    private _fetchUserToken;
    private _refreshUserTokenWithCallback;
    private _fetchAppToken;
    private _refreshAppToken;
}
export {};
//# sourceMappingURL=RefreshingAuthProvider.d.ts.map