"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TwitchPrivateMessage = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@twurple/common");
const ircv3_1 = require("ircv3");
const ChatUser_1 = require("../ChatUser");
const emoteUtil_1 = require("../utils/emoteUtil");
/**
 * An IRC PRIVMSG, with easy accessors for commonly used data from its tags.
 */
let TwitchPrivateMessage = class TwitchPrivateMessage extends ircv3_1.MessageTypes.Commands.PrivateMessage {
    /**
     * The ID of the message.
     */
    get id() {
        return this._tags.get('id');
    }
    /**
     * The date the message was sent at.
     */
    get date() {
        const timestamp = this._tags.get('tmi-sent-ts');
        return new Date(Number(timestamp));
    }
    /**
     * Info about the user that send the message, like their user ID and their status in the current channel.
     */
    get userInfo() {
        return new ChatUser_1.ChatUser(this._prefix.nick, this._tags);
    }
    /**
     * The ID of the channel the message is in.
     */
    get channelId() {
        var _a;
        return (_a = this._tags.get('room-id')) !== null && _a !== void 0 ? _a : null;
    }
    /**
     * Whether the message is a cheer.
     */
    get isCheer() {
        return this._tags.has('bits');
    }
    /**
     * Whether the message represents a redemption of a custom channel points reward.
     */
    get isRedemption() {
        return this._tags.has('custom-reward-id');
    }
    /**
     * Whether the message is highlighted by using channel points.
     */
    get isHighlight() {
        return this._tags.get('msg-id') === 'highlighted-message';
    }
    /**
     * The number of bits cheered with the message.
     */
    get bits() {
        var _a;
        return Number((_a = this._tags.get('bits')) !== null && _a !== void 0 ? _a : 0);
    }
    /**
     * The offsets of emote usages in the message.
     */
    get emoteOffsets() {
        return (0, emoteUtil_1.parseEmoteOffsets)(this._tags.get('emotes'));
    }
    /**
     * Parses the message, separating text from emote usages.
     */
    parseEmotes() {
        let messageText = this.params.content;
        const ctcp = (0, ircv3_1.decodeCtcp)(messageText);
        if (ctcp && ctcp.command === 'ACTION') {
            messageText = ctcp.params;
        }
        const foundEmotes = (0, emoteUtil_1.parseEmotePositions)(messageText, this.emoteOffsets);
        return (0, common_1.fillTextPositions)(messageText, foundEmotes);
    }
    /**
     * Parses the message, separating text from emote usages and cheers.
     *
     * @param cheermotes A list of cheermotes.
     * @param cheermoteFormat The format to show the cheermotes in.
     */
    parseEmotesAndBits(cheermotes, cheermoteFormat) {
        const messageText = this.params.content;
        const foundCheermotes = cheermotes.parseMessage(messageText, cheermoteFormat);
        const foundEmotesAndCheermotes = [
            ...(0, emoteUtil_1.parseEmotePositions)(messageText, this.emoteOffsets),
            ...foundCheermotes.map((cheermote) => ({
                type: 'cheer',
                position: cheermote.position,
                length: cheermote.length,
                name: cheermote.name,
                amount: cheermote.amount,
                displayInfo: cheermote.displayInfo
            }))
        ];
        foundEmotesAndCheermotes.sort((a, b) => a.position - b.position);
        return (0, common_1.fillTextPositions)(messageText, foundEmotesAndCheermotes);
    }
};
TwitchPrivateMessage = tslib_1.__decorate([
    (0, common_1.rtfm)('chat', 'TwitchPrivateMessage', 'id')
], TwitchPrivateMessage);
exports.TwitchPrivateMessage = TwitchPrivateMessage;
