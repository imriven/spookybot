import type { UserIdResolvable } from '@twurple/common';
import { type HelixEventSubSubscriptionStatus } from '../../../interfaces/helix/eventSub.external';
import { type HelixEventSubTransportOptions, type HelixPaginatedEventSubSubscriptionsResult } from '../../../interfaces/helix/eventSub.input';
import { BaseApi } from '../../BaseApi';
import type { HelixPagination } from '../HelixPagination';
import { HelixEventSubSubscription } from './HelixEventSubSubscription';
import { HelixPaginatedEventSubSubscriptionsRequest } from './HelixPaginatedEventSubSubscriptionsRequest';
/**
 * The API methods that deal with EventSub.
 *
 * Can be accessed using `client.eventSub` on an {@link ApiClient} instance.
 *
 * ## Before using these methods...
 *
 * All methods in this class assume that you are already running a working EventSub listener reachable using the given transport.
 *
 * If you don't already have one, we recommend use of the `@twurple/eventsub-http` or `@twurple/eventsub-ws` libraries,
 * which handle subscribing and unsubscribing to these topics automatically.
 *
 * ## Example
 * ```ts
 * const api = new ApiClient(new StaticAuthProvider(clientId, accessToken));
 * await api.eventSub.subscribeToUserFollowsTo('125328655', { callbackUrl: 'https://example.com' });
 * ```
 *
 * @meta category helix
 * @meta categorizedTitle EventSub
 */
export declare class HelixEventSubApi extends BaseApi {
    /**
     * Retrieves the current EventSub subscriptions for the current client.
     *
     * Requires an app access token to work; does not work with user tokens.
     *
     * @param pagination
     *
     * @expandParams
     */
    getSubscriptions(pagination?: HelixPagination): Promise<HelixPaginatedEventSubSubscriptionsResult>;
    /**
     * Creates a paginator for the current EventSub subscriptions for the current client.
     *
     * Requires an app access token to work; does not work with user tokens.
     */
    getSubscriptionsPaginated(): HelixPaginatedEventSubSubscriptionsRequest;
    /**
     * Retrieves the current EventSub subscriptions with the given status for the current client.
     *
     * Requires an app access token to work; does not work with user tokens.
     *
     * @param status The status of the subscriptions to retrieve.
     * @param pagination
     *
     * @expandParams
     */
    getSubscriptionsForStatus(status: HelixEventSubSubscriptionStatus, pagination?: HelixPagination): Promise<HelixPaginatedEventSubSubscriptionsResult>;
    /**
     * Creates a paginator for the current EventSub subscriptions with the given status for the current client.
     *
     * Requires an app access token to work; does not work with user tokens.
     *
     * @param status The status of the subscriptions to retrieve.
     */
    getSubscriptionsForStatusPaginated(status: HelixEventSubSubscriptionStatus): HelixPaginatedEventSubSubscriptionsRequest;
    /**
     * Retrieves the current EventSub subscriptions with the given type for the current client.
     *
     * Requires an app access token to work; does not work with user tokens.
     *
     * @param type The type of the subscriptions to retrieve.
     * @param pagination
     *
     * @expandParams
     */
    getSubscriptionsForType(type: string, pagination?: HelixPagination): Promise<HelixPaginatedEventSubSubscriptionsResult>;
    /**
     * Creates a paginator for the current EventSub subscriptions with the given type for the current client.
     *
     * Requires an app access token to work; does not work with user tokens.
     *
     * @param type The type of the subscriptions to retrieve.
     */
    getSubscriptionsForTypePaginated(type: string): HelixPaginatedEventSubSubscriptionsRequest;
    /**
     * Retrieves the current EventSub subscriptions for the current user and client.
     *
     * Requires an app access token to work; does not work with user tokens.
     *
     * @param user The user to retrieve subscriptions for.
     * @param pagination
     *
     * @expandParams
     */
    getSubscriptionsForUser(user: UserIdResolvable, pagination?: HelixPagination): Promise<HelixPaginatedEventSubSubscriptionsResult>;
    /**
     * Creates a paginator for the current EventSub subscriptions with the given type for the current client.
     *
     * Requires an app access token to work; does not work with user tokens.
     *
     * @param user The user to retrieve subscriptions for.
     */
    getSubscriptionsForUserPaginated(user: UserIdResolvable): HelixPaginatedEventSubSubscriptionsRequest;
    /**
     * Sends an arbitrary request to subscribe to an event.
     *
     * Requires an app access token to work; does not work with user tokens.
     *
     * @param type The type of the event.
     * @param version The version of the event.
     * @param condition The condition of the subscription.
     * @param transport The transport of the subscription.
     * @param requiredScope The scope required by the subscription. Will only be checked for applicable transports.
     */
    createSubscription(type: string, version: string, condition: Record<string, unknown>, transport: HelixEventSubTransportOptions, requiredScope?: string): Promise<HelixEventSubSubscription>;
    /**
     * Deletes a subscription.
     *
     * @param id The ID of the subscription.
     */
    deleteSubscription(id: string): Promise<void>;
    /**
     * Deletes *all* subscriptions.
     */
    deleteAllSubscriptions(): Promise<void>;
    /**
     * Deletes all broken subscriptions, i.e. all that are not enabled or pending verification.
     */
    deleteBrokenSubscriptions(): Promise<void>;
    /**
     * Subscribe to events that represent a stream going live.
     *
     * @param broadcaster The broadcaster you want to listen to online events for.
     * @param transport The transport options
     */
    subscribeToStreamOnlineEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a stream going offline.
     *
     * @param broadcaster The broadcaster you want to listen to online events for.
     * @param transport The transport options
     */
    subscribeToStreamOfflineEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a channel updating their metadata.
     *
     * @param broadcaster The broadcaster you want to listen to update events for.
     * @param transport The transport options
     */
    subscribeToChannelUpdateEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a user following a channel.
     *
     * @param broadcaster  The broadcaster you want to listen to follow events for.
     * @param transport The transport options
     */
    subscribeToChannelFollowEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a user subscribing to a channel.
     *
     * @param broadcaster The broadcaster you want to listen to subscribe events for.
     * @param transport The transport options
     */
    subscribeToChannelSubscriptionEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a user gifting another user a subscription to a channel.
     *
     * @param broadcaster The broadcaster you want to listen to subscription gift events for.
     * @param transport The transport options
     */
    subscribeToChannelSubscriptionGiftEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a user's subscription to a channel being announced.
     *
     * @param broadcaster The broadcaster you want to listen to subscription message events for.
     * @param transport The transport options
     */
    subscribeToChannelSubscriptionMessageEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a user's subscription to a channel ending.
     *
     * @param broadcaster The broadcaster you want to listen to subscription end events for.
     * @param transport The transport options
     */
    subscribeToChannelSubscriptionEndEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a user cheering bits to a channel.
     *
     * @param broadcaster The broadcaster you want to listen to cheer events for.
     * @param transport The transport options.
     */
    subscribeToChannelCheerEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a charity campaign starting in a channel.
     *
     * @param broadcaster The broadcaster you want to listen to charity donation events for.
     * @param transport The transport option.
     */
    subscribeToChannelCharityCampaignStartEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a charity campaign ending in a channel.
     *
     * @param broadcaster The broadcaster you want to listen to charity donation events for.
     * @param transport The transport option.
     */
    subscribeToChannelCharityCampaignStopEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a user donating to a charity campaign in a channel.
     *
     * @param broadcaster The broadcaster you want to listen to charity donation events for.
     * @param transport The transport option.
     */
    subscribeToChannelCharityDonationEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a charity campaign progressing in a channel.
     *
     * @param broadcaster The broadcaster you want to listen to charity donation events for.
     * @param transport The transport option.
     */
    subscribeToChannelCharityCampaignProgressEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a user being banned in a channel.
     *
     * @param broadcaster The broadcaster you want to listen to ban events for.
     * @param transport The transport option.
     */
    subscribeToChannelBanEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a user being unbanned in a channel.
     *
     * @param broadcaster The broadcaster you want to listen to unban events for.
     * @param transport The transport options.
     */
    subscribeToChannelUnbanEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent Shield Mode being activated in a channel.
     *
     * @param broadcaster The broadcaster you want to listen to Shield Mode activation events for.
     * @param moderator A user that has permission to read Shield Mode status in the broadcaster's channel.
     * @param transport The transport options.
     */
    subscribeToChannelShieldModeBeginEvents(broadcaster: UserIdResolvable, moderator: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent Shield Mode being deactivated in a channel.
     *
     * @param broadcaster The broadcaster you want to listen to Shield Mode deactivation events for.
     * @param moderator A user that has permission to read Shield Mode status in the broadcaster's channel.
     * @param transport The transport options.
     */
    subscribeToChannelShieldModeEndEvents(broadcaster: UserIdResolvable, moderator: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a moderator being added to a channel.
     *
     * @param broadcaster The broadcaster you want to listen for moderator add events for.
     * @param transport The transport options.
     */
    subscribeToChannelModeratorAddEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a moderator being removed from a channel.
     *
     * @param broadcaster The broadcaster you want to listen for moderator remove events for.
     * @param transport The transport options.
     */
    subscribeToChannelModeratorRemoveEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a broadcaster raiding another broadcaster.
     *
     * @param broadcaster The broadcaster you want to listen to outgoing raid events for.
     * @param transport The transport options.
     */
    subscribeToChannelRaidEventsFrom(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a broadcaster being raided by another broadcaster.
     *
     * @param broadcaster The broadcaster you want to listen to incoming raid events for.
     * @param transport The transport options.
     */
    subscribeToChannelRaidEventsTo(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a Channel Points reward being added to a channel.
     *
     * @param broadcaster The broadcaster you want to listen to reward add events for.
     * @param transport The transport options.
     */
    subscribeToChannelRewardAddEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a Channel Points reward being updated in a channel.
     *
     * @param broadcaster The broadcaster you want to listen to reward update events for.
     * @param transport The transport options.
     */
    subscribeToChannelRewardUpdateEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a specific Channel Points reward being updated.
     *
     * @param broadcaster The broadcaster you want to listen to reward update events for.
     * @param rewardId The ID of the reward you want to listen to update events for.
     * @param transport The transport options.
     */
    subscribeToChannelRewardUpdateEventsForReward(broadcaster: UserIdResolvable, rewardId: string, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a Channel Points reward being removed from a channel.
     *
     * @param broadcaster The broadcaster you want to listen to reward remove events for.
     * @param transport The transport options.
     */
    subscribeToChannelRewardRemoveEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a specific Channel Points reward being removed from a channel.
     *
     * @param broadcaster The broadcaster you want to listen to reward remove events for.
     * @param rewardId The ID of the reward you want to listen to remove events for.
     * @param transport The transport options.
     */
    subscribeToChannelRewardRemoveEventsForReward(broadcaster: UserIdResolvable, rewardId: string, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a Channel Points reward being redeemed.
     *
     * @param broadcaster The broadcaster you want to listen to redemption events for.
     * @param transport The transport options.
     */
    subscribeToChannelRedemptionAddEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a specific Channel Points reward being redeemed.
     *
     * @param broadcaster The broadcaster you want to listen to redemption events for.
     * @param rewardId The ID of the reward you want to listen to redemption events for.
     * @param transport The transport options.
     */
    subscribeToChannelRedemptionAddEventsForReward(broadcaster: UserIdResolvable, rewardId: string, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a Channel Points redemption being updated.
     *
     * @param broadcaster The broadcaster you want to listen to redemption update events for.
     * @param transport The transport options.
     */
    subscribeToChannelRedemptionUpdateEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a specific Channel Points reward's redemption being updated.
     *
     * @param broadcaster The broadcaster you want to listen to redemption update events for.
     * @param rewardId The ID of the reward you want to listen to redemption updates for.
     * @param transport The transport options.
     */
    subscribeToChannelRedemptionUpdateEventsForReward(broadcaster: UserIdResolvable, rewardId: string, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a poll starting in a channel.
     *
     * @param broadcaster The broadcaster you want to listen to poll begin events for.
     * @param transport The transport options.
     */
    subscribeToChannelPollBeginEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a poll being voted on in a channel.
     *
     * @param broadcaster The broadcaster you want to listen to poll progress events for.
     * @param transport The transport options.
     */
    subscribeToChannelPollProgressEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a poll ending in a channel.
     *
     * @param broadcaster The broadcaster you want to listen to poll end events for.
     * @param transport The transport options.
     */
    subscribeToChannelPollEndEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a prediction starting in a channel.
     *
     * @param broadcaster The broadcaster you want to listen to prediction begin events for.
     * @param transport The transport options.
     */
    subscribeToChannelPredictionBeginEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a prediction being voted on in a channel.
     *
     * @param broadcaster The broadcaster you want to listen to prediction preogress events for.
     * @param transport The transport options.
     */
    subscribeToChannelPredictionProgressEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a prediction being locked in a channel.
     *
     * @param broadcaster The broadcaster you want to listen to prediction lock events for.
     * @param transport The transport options.
     */
    subscribeToChannelPredictionLockEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a prediction ending in a channel.
     *
     * @param broadcaster The broadcaster you want to listen to prediction end events for.
     * @param transport The transport options.
     */
    subscribeToChannelPredictionEndEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent the beginning of a creator goal event in a channel.
     *
     * @param broadcaster The broadcaster you want to listen to goal begin events for.
     * @param transport The transport options.
     */
    subscribeToChannelGoalBeginEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent progress towards a creator goal.
     *
     * @param broadcaster The broadcaster for which you want to listen to goal progress events.
     * @param transport The transport options.
     */
    subscribeToChannelGoalProgressEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent the end of a creator goal event.
     *
     * @param broadcaster The broadcaster for which you want to listen to goal end events.
     * @param transport The transport options.
     */
    subscribeToChannelGoalEndEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent the beginning of a Hype Train event in a channel.
     *
     * @param broadcaster The broadcaster you want to listen to Hype train begin events for.
     * @param transport The transport options.
     */
    subscribeToChannelHypeTrainBeginEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent progress towards the Hype Train goal.
     *
     * @param broadcaster The broadcaster for which you want to listen to Hype Train progress events.
     * @param transport The transport options.
     */
    subscribeToChannelHypeTrainProgressEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent the end of a Hype Train event.
     *
     * @param broadcaster The broadcaster for which you want to listen to Hype Train end events.
     * @param transport The transport options.
     */
    subscribeToChannelHypeTrainEndEvents(broadcaster: UserIdResolvable, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent an extension Bits transaction.
     *
     * @param clientId The Client ID for the extension you want to listen to Bits transactions for.
     * @param transport The transport options.
     */
    subscribeToExtensionBitsTransactionCreateEvents(clientId: string, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a user granting authorization to an application.
     *
     * @param clientId The Client ID for the application you want to listen to authorization grant events for.
     * @param transport The transport options.
     */
    subscribeToUserAuthorizationGrantEvents(clientId: string, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a user revoking their authorization from an application.
     *
     * @param clientId The Client ID for the application you want to listen to authorization revoke events for.
     * @param transport The transport options.
     */
    subscribeToUserAuthorizationRevokeEvents(clientId: string, transport: HelixEventSubTransportOptions): Promise<HelixEventSubSubscription>;
    /**
     * Subscribe to events that represent a user updating their account details.
     *
     * @param user The user you want to listen to user update events for.
     * @param transport The transport options.
     * @param withEmail Whether to request adding the email address of the user to the notification.
     *
     * Only has an effect with the websocket transport.
     * With the webhook transport, this depends solely on the previous authorization given by the user.
     */
    subscribeToUserUpdateEvents(user: UserIdResolvable, transport: HelixEventSubTransportOptions, withEmail?: boolean): Promise<HelixEventSubSubscription>;
    private _deleteSubscriptionsWithCondition;
}
//# sourceMappingURL=HelixEventSubApi.d.ts.map