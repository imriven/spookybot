import { __decorate } from "tslib";
import { Cacheable, CachedGetter } from '@d-fischer/cache-decorators';
import { isNode } from '@d-fischer/detect-node';
import { createLogger } from '@d-fischer/logger';
import { TimeBasedRateLimiter } from '@d-fischer/rate-limiter';
import { callTwitchApi, callTwitchApiRaw, handleTwitchApiResponseError, HttpStatusCodeError, transformTwitchApiResponse } from '@twurple/api-call';
import { accessTokenIsExpired, InvalidTokenError, TokenInfo } from '@twurple/auth';
import { rtfm } from '@twurple/common';
import { BadgesApi } from "./api/badges/BadgesApi.mjs";
import { HelixBitsApi } from "./api/helix/bits/HelixBitsApi.mjs";
import { HelixChannelApi } from "./api/helix/channel/HelixChannelApi.mjs";
import { HelixChannelPointsApi } from "./api/helix/channelPoints/HelixChannelPointsApi.mjs";
import { HelixCharityApi } from "./api/helix/charity/HelixCharityApi.mjs";
import { HelixChatApi } from "./api/helix/chat/HelixChatApi.mjs";
import { HelixClipApi } from "./api/helix/clip/HelixClipApi.mjs";
import { HelixEventSubApi } from "./api/helix/eventSub/HelixEventSubApi.mjs";
import { HelixExtensionsApi } from "./api/helix/extensions/HelixExtensionsApi.mjs";
import { HelixGameApi } from "./api/helix/game/HelixGameApi.mjs";
import { HelixGoalApi } from "./api/helix/goals/HelixGoalApi.mjs";
import { HelixApiGroup } from "./api/helix/HelixApiGroup.mjs";
import { HelixRateLimiter } from "./api/helix/HelixRateLimiter.mjs";
import { HelixHypeTrainApi } from "./api/helix/hypeTrain/HelixHypeTrainApi.mjs";
import { HelixModerationApi } from "./api/helix/moderation/HelixModerationApi.mjs";
import { HelixPollApi } from "./api/helix/poll/HelixPollApi.mjs";
import { HelixPredictionApi } from "./api/helix/prediction/HelixPredictionApi.mjs";
import { HelixRaidApi } from "./api/helix/raids/HelixRaidApi.mjs";
import { HelixScheduleApi } from "./api/helix/schedule/HelixScheduleApi.mjs";
import { HelixSearchApi } from "./api/helix/search/HelixSearchApi.mjs";
import { HelixStreamApi } from "./api/helix/stream/HelixStreamApi.mjs";
import { HelixSubscriptionApi } from "./api/helix/subscriptions/HelixSubscriptionApi.mjs";
import { HelixTagApi } from "./api/helix/tag/HelixTagApi.mjs";
import { HelixTeamApi } from "./api/helix/team/HelixTeamApi.mjs";
import { HelixUserApi } from "./api/helix/user/HelixUserApi.mjs";
import { HelixVideoApi } from "./api/helix/video/HelixVideoApi.mjs";
import { HelixWhisperApi } from "./api/helix/whisper/HelixWhisperApi.mjs";
import { UnsupportedApi } from "./api/unsupported/UnsupportedApi.mjs";
import { ConfigError } from "./errors/ConfigError.mjs";
/**
 * An API client for the Twitch Helix API and other miscellaneous endpoints.
 *
 * @meta category main
 */
let ApiClient = class ApiClient {
    /**
     * Creates a new API client instance.
     *
     * @param config Configuration for the client instance.
     */
    constructor(config) {
        if (!config.authProvider) {
            throw new ConfigError('No auth provider given. Please supply the `authProvider` option.');
        }
        this._config = config;
        this._logger = createLogger({ name: 'twurple:api:client', ...config.logger });
        const rateLimitLoggerOptions = { name: 'twurple:api:rate-limiter', ...config.logger };
        this._rateLimiter = isNode
            ? new HelixRateLimiter({ logger: rateLimitLoggerOptions })
            : new TimeBasedRateLimiter({
                logger: rateLimitLoggerOptions,
                bucketSize: 800,
                timeFrame: 64000,
                doRequest: async ({ options, clientId, accessToken, authorizationType, fetchOptions }) => await callTwitchApiRaw(options, clientId, accessToken, authorizationType, fetchOptions)
            });
    }
    /**
     * Requests scopes from the auth provider.
     *
     * @param scopes The scopes to request.
     */
    async requestScopes(scopes) {
        await this._config.authProvider.getAccessToken(scopes);
    }
    /**
     * Retrieves information about your access token.
     */
    async getTokenInfo() {
        try {
            const data = await this.callApi({ type: 'auth', url: 'validate' });
            return new TokenInfo(data);
        }
        catch (e) {
            if (e instanceof HttpStatusCodeError && e.statusCode === 401) {
                throw new InvalidTokenError({ cause: e });
            }
            throw e;
        }
    }
    /**
     * Makes a call to the Twitch API using your access token.
     *
     * @param options The configuration of the call.
     */
    async callApi(options) {
        var _a;
        const { authProvider } = this._config;
        const shouldAuth = (_a = options.auth) !== null && _a !== void 0 ? _a : true;
        let accessToken = shouldAuth
            ? await authProvider.getAccessToken(options.scope ? [options.scope] : undefined)
            : null;
        if (!accessToken) {
            return await callTwitchApi(options, authProvider.clientId, undefined, undefined, this._config.fetchOptions);
        }
        if (accessTokenIsExpired(accessToken) && authProvider.refresh) {
            const newAccessToken = await authProvider.refresh();
            if (newAccessToken) {
                accessToken = newAccessToken;
            }
        }
        const authorizationType = authProvider.authorizationType;
        let response = await this._callApiInternal(options, authProvider.clientId, accessToken.accessToken, authorizationType);
        if (response.status === 401 && authProvider.refresh) {
            await authProvider.refresh();
            accessToken = await authProvider.getAccessToken(options.scope ? [options.scope] : []);
            if (accessToken) {
                response = await this._callApiInternal(options, authProvider.clientId, accessToken.accessToken, authorizationType);
            }
        }
        await handleTwitchApiResponseError(response, options);
        return await transformTwitchApiResponse(response);
    }
    /**
     * A group of Helix API methods.
     *
     * @deprecated Please remove `.helix` from your calls to access the API namespaces directly.
     */
    get helix() {
        return new HelixApiGroup(this);
    }
    /**
     * The Helix bits API methods.
     */
    get bits() {
        return new HelixBitsApi(this);
    }
    /**
     * The Helix channels API methods.
     */
    get channels() {
        return new HelixChannelApi(this);
    }
    /**
     * The Helix channel points API methods.
     */
    get channelPoints() {
        return new HelixChannelPointsApi(this);
    }
    /**
     * The Helix charity API methods.
     */
    get charity() {
        return new HelixCharityApi(this);
    }
    /**
     * The Helix chat API methods.
     */
    get chat() {
        return new HelixChatApi(this);
    }
    /**
     * The Helix clips API methods.
     */
    get clips() {
        return new HelixClipApi(this);
    }
    /**
     * The Helix EventSub API methods.
     */
    get eventSub() {
        return new HelixEventSubApi(this);
    }
    /**
     * The Helix extensions API methods.
     */
    get extensions() {
        return new HelixExtensionsApi(this);
    }
    /**
     * The Helix game API methods.
     */
    get games() {
        return new HelixGameApi(this);
    }
    /**
     * The Helix Hype Train API methods.
     */
    get hypeTrain() {
        return new HelixHypeTrainApi(this);
    }
    /**
     * The Helix goal API methods.
     */
    get goals() {
        return new HelixGoalApi(this);
    }
    /**
     * The Helix moderation API methods.
     */
    get moderation() {
        return new HelixModerationApi(this);
    }
    /**
     * The Helix poll API methods.
     */
    get polls() {
        return new HelixPollApi(this);
    }
    /**
     * The Helix prediction API methods.
     */
    get predictions() {
        return new HelixPredictionApi(this);
    }
    /**
     * The Helix raid API methods.
     */
    get raids() {
        return new HelixRaidApi(this);
    }
    /**
     * The Helix schedule API methods.
     */
    get schedule() {
        return new HelixScheduleApi(this);
    }
    /**
     * The Helix search API methods.
     */
    get search() {
        return new HelixSearchApi(this);
    }
    /**
     * The Helix stream API methods.
     */
    get streams() {
        return new HelixStreamApi(this);
    }
    /**
     * The Helix subscription API methods.
     */
    get subscriptions() {
        return new HelixSubscriptionApi(this);
    }
    /**
     * The Helix tag API methods.
     *
     * @deprecated
     */
    get tags() {
        return new HelixTagApi(this);
    }
    /**
     * The Helix team API methods.
     */
    get teams() {
        return new HelixTeamApi(this);
    }
    /**
     * The Helix user API methods.
     */
    get users() {
        return new HelixUserApi(this);
    }
    /**
     * The Helix video API methods.
     */
    get videos() {
        return new HelixVideoApi(this);
    }
    /**
     * The API methods that deal with whispers.
     */
    get whispers() {
        return new HelixWhisperApi(this);
    }
    /**
     * The API methods that deal with badges.
     *
     * @deprecated Use {@link HelixChatApi}'s badge methods instead.
     */
    get badges() {
        return new BadgesApi(this);
    }
    /**
     * Various API methods that are not officially supported by Twitch.
     */
    get unsupported() {
        return new UnsupportedApi(this);
    }
    /**
     * The last known rate limit for the Helix API.
     */
    get lastKnownLimit() {
        if (this._rateLimiter instanceof HelixRateLimiter) {
            return this._rateLimiter.lastKnownLimit;
        }
        return null;
    }
    /**
     * The last known remaining requests for the Helix API.
     */
    get lastKnownRemainingRequests() {
        if (this._rateLimiter instanceof HelixRateLimiter) {
            return this._rateLimiter.lastKnownRemainingRequests;
        }
        return null;
    }
    /**
     * The last known rate limit reset date for the Helix API.
     */
    get lastKnownResetDate() {
        if (this._rateLimiter instanceof HelixRateLimiter) {
            return this._rateLimiter.lastKnownResetDate;
        }
        return null;
    }
    /** @private */
    get _authProvider() {
        return this._config.authProvider;
    }
    async _callApiInternal(options, clientId, accessToken, authorizationType) {
        var _a, _b, _c;
        const { fetchOptions } = this._config;
        const type = (_a = options.type) !== null && _a !== void 0 ? _a : 'helix';
        this._logger.debug(`Calling ${type} API: ${(_b = options.method) !== null && _b !== void 0 ? _b : 'GET'} ${options.url}`);
        this._logger.trace(`Query: ${JSON.stringify(options.query)}`);
        if (options.jsonBody) {
            this._logger.trace(`Request body: ${JSON.stringify(options.jsonBody)}`);
        }
        const response = type === 'helix'
            ? await this._rateLimiter.request({
                options,
                clientId,
                accessToken,
                authorizationType,
                fetchOptions
            })
            : await callTwitchApiRaw(options, clientId, accessToken, authorizationType, fetchOptions);
        this._logger.debug(`Called ${type} API: ${(_c = options.method) !== null && _c !== void 0 ? _c : 'GET'} ${options.url} - result: ${response.status}`);
        return response;
    }
};
__decorate([
    CachedGetter()
], ApiClient.prototype, "helix", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "bits", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "channels", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "channelPoints", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "charity", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "chat", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "clips", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "eventSub", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "extensions", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "games", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "hypeTrain", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "goals", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "moderation", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "polls", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "predictions", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "raids", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "schedule", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "search", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "streams", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "subscriptions", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "tags", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "teams", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "users", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "videos", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "whispers", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "badges", null);
__decorate([
    CachedGetter()
], ApiClient.prototype, "unsupported", null);
ApiClient = __decorate([
    Cacheable,
    rtfm('api', 'ApiClient')
], ApiClient);
export { ApiClient };
